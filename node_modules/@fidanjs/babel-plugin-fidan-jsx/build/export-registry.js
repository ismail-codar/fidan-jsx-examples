"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const babel = require("@babel/core");
const t = require("@babel/types");
const _1 = require(".");
const registryData = {};
function buildBabelConfig(plugin) {
    const config = _1.globalOptions.babelConfig(null);
    return Object.assign({}, config, {
        plugins: [plugin].concat(config.plugins)
    });
}
const getDeclationsFromExports = (path) => {
    let parentPath = path.parentPath;
    while (!t.isAssignmentExpression(parentPath.node)) {
        parentPath = parentPath.parentPath;
        if (!parentPath) {
            return [];
        }
    }
    if (t.isAssignmentExpression(parentPath.node)) {
        if (t.isIdentifier(parentPath.node.right)) {
            const variableBindings = exports.variableBindingInScope(parentPath.scope, parentPath.node.right.name);
            return [variableBindings.path.node];
        }
    }
};
const getExportPaths = (fileName) => {
    const localExports = [];
    if (fs.existsSync(fileName)) {
        babel.transformFileSync(fileName, buildBabelConfig(() => {
            return {
                visitor: {
                    ExportNamedDeclaration(p) {
                        localExports.push.apply(localExports, getDeclationsFromNamedExport(p.node));
                    },
                    Identifier(path, file) {
                        const parentNode = path.parent;
                        if (path.node.name === "exports") {
                            if (t.isMemberExpression(path.parent)) {
                                localExports.push.apply(localExports, getDeclationsFromExports(path));
                            }
                        }
                    }
                }
            };
        }));
    }
    return localExports;
};
const getDeclationsFromNamedExport = (node) => {
    if (t.isFunctionDeclaration(node.declaration))
        return [node.declaration];
    else if (t.isVariableDeclaration(node.declaration))
        return node.declaration.declarations;
    else if (t.isTypeAlias(node.declaration))
        return [node.declaration];
    else
        return [];
};
const loadImportedFileExports = (fileName, importedFile) => {
    if (importedFile.startsWith(".") === false &&
        importedFile.startsWith("/") == false &&
        importedFile.startsWith("~/") == false) {
        return { nodes: [] };
    }
    if (registryData[fileName])
        return registryData[fileName];
    else {
        importedFile = path.resolve(path.dirname(fileName), importedFile);
        _1.globalOptions.fileExtentions.forEach(ext => {
            if (fs.existsSync(importedFile + ext)) {
                importedFile += ext;
            }
        });
        registryData[fileName] = {
            fileName: importedFile,
            nodes: getExportPaths(importedFile)
        };
        return registryData[fileName];
    }
};
exports.variableBindingInScope = (scope, searchName) => {
    while (scope != null && searchName) {
        for (var bindingKey in scope.bindings) {
            if (bindingKey == searchName) {
                return scope.bindings[bindingKey];
            }
        }
        scope = scope.parent;
    }
    return null;
};
exports.declarationInScope = (scope, searchName) => {
    const variableBinding = exports.variableBindingInScope(scope, searchName);
    if (!variableBinding)
        return false;
    if (t.isVariableDeclarator(variableBinding.path.node)) {
        return variableBinding.path.node;
    }
    else if (t.isImportSpecifier(variableBinding.path.node) ||
        t.isImportDefaultSpecifier(variableBinding.path.node)) {
        const exported = loadImportedFileExports(_1.globalOptions.currentFile.path, variableBinding.path.parent["source"].value);
        return exported.nodes.find(node => {
            if (t.isVariableDeclarator(node) && t.isIdentifier(node.id)) {
                return node.id.name === searchName;
            }
            else {
                debugger;
            }
            return false;
        });
    }
};
//# sourceMappingURL=export-registry.js.map