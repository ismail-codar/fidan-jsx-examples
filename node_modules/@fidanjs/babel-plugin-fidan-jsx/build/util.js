"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const t = require("@babel/types");
const _1 = require(".");
const svg_1 = require("./svg");
const generator_1 = require("@babel/generator");
exports.generateCode = node => {
    return generator_1.default(node).code;
};
function getTagName(tag) {
    if (t.isJSXMemberExpression(tag.openingElement.name)) {
        return `${tag.openingElement.name.object.name}.${tag.openingElement.name.property.name}`;
    }
    else if (t.isJSXIdentifier(tag.openingElement.name)) {
        return tag.openingElement.name.name;
    }
}
exports.getTagName = getTagName;
function checkParens(jsx, path) {
    const e = path.hub.file.code.slice(jsx.start + 1, jsx.end - 1).trim();
    return e[0] === "(" && e[e.length - 1] === ")";
}
exports.checkParens = checkParens;
function toEventName(name) {
    name = name.slice(2).toLowerCase();
    if (name === "doubleclick")
        name = "dblclick";
    return name;
}
exports.toEventName = toEventName;
function trimWhitespace(text) {
    return text
        .split("\n")
        .map((t, i) => {
        if (/^\s*$/.test(t))
            return "";
        if (i === 0)
            return t.replace(/\s+/g, " ");
        return t.replace(/^\s+/g, "").replace(/\s+/g, " ");
    })
        .join("");
}
exports.trimWhitespace = trimWhitespace;
function checkLength(children) {
    let i = 0;
    children.forEach(child => {
        if (!t.isJSXText(child) || !/^\s*$/.test(child.value))
            i++;
    });
    return i > 1;
}
exports.checkLength = checkLength;
// reduce unnecessary refs
function detectExpressions(jsx, index) {
    for (let i = index; i < jsx.children.length; i++) {
        if (t.isJSXExpressionContainer(jsx.children[i]))
            return true;
        if (t.isJSXElement(jsx.children[i])) {
            const tagName = getTagName(jsx.children[i]);
            if (tagName.toLowerCase() !== tagName)
                return true;
            if (jsx.children[i].openingElement.attributes.some(attr => t.isJSXSpreadAttribute(attr) ||
                t.isJSXExpressionContainer(attr.value)))
                return true;
            if (jsx.children[i].children.length)
                if (detectExpressions(jsx.children[i], 0))
                    return true;
        }
    }
}
exports.detectExpressions = detectExpressions;
exports.insertFidanImport = (body) => {
    body.splice(0, 0, t.variableDeclaration("var", [
        t.variableDeclarator(t.identifier(_1.globalOptions.moduleName), t.callExpression(t.identifier("require"), [
            t.stringLiteral("@fidanjs/jsx")
        ]))
    ]));
};
exports.isComponentNode = (id) => {
    let tagName = t.isIdentifier(id)
        ? id.name
        : t.isMemberExpression(id)
            ? t.isIdentifier(id.property)
                ? id.property.name
                : id.property
            : null;
    return exports.isComponentName(tagName);
};
exports.isComponentTag = jsx => {
    let tagName = getTagName(jsx);
    return exports.isComponentName(tagName);
};
exports.isComponentName = (tagName) => tagName.substr(0, 1) !== tagName.substr(0, 1).toLowerCase();
exports.canBeReactive = (value) => {
    const reactive = t.isCallExpression(value) &&
        value.arguments.length == 0 &&
        !exports.isComponentNode(value.callee);
    return reactive;
};
exports.isSvgElementTagName = tagName => {
    const openedTags = _1.globalOptions.openedTags;
    return ((tagName != null && svg_1.allSvgElements.indexOf(tagName) !== -1) ||
        (svg_1.htmlAndSvgElements.indexOf(tagName) !== -1 &&
            svg_1.allSvgElements.indexOf(openedTags[openedTags.length - 1]) !== -1));
};
exports.jsxParentComponent = (path) => {
    if (!path.parentPath ||
        !path.parentPath.parentPath ||
        !path.parentPath.parentPath.parentPath ||
        !path.parentPath.parentPath.parentPath.parentPath)
        return null;
    const declarationNode = path.parentPath.parentPath.parentPath.parentPath.node;
    let componentName = null;
    if (t.isVariableDeclarator(declarationNode)) {
        componentName = declarationNode.id["name"];
        if (exports.isComponentName(componentName) &&
            (t.isArrowFunctionExpression(declarationNode.init) ||
                t.isFunctionExpression(declarationNode.init))) {
            if (declarationNode.init.params.length === 1 &&
                t.isIdentifier(declarationNode.init.params[0])) {
                return {
                    componentName,
                    params: declarationNode.init.params
                };
            }
        }
    }
    if (t.isFunctionDeclaration(declarationNode)) {
        const componentName = declarationNode.id["name"];
        if (exports.isComponentName(componentName)) {
            if (declarationNode.params.length === 1 &&
                t.isIdentifier(declarationNode.params[0])) {
                return {
                    componentName,
                    params: declarationNode.params
                };
            }
        }
    }
    return null;
};
exports.setComponentPropsToDom = (path, result) => {
    const parentComponent = exports.jsxParentComponent(path);
    if (parentComponent && parentComponent.params.length === 1) {
        //_el$.$props = props;
        result.exprs.push(t.expressionStatement(t.assignmentExpression("=", t.memberExpression(result.id, t.identifier("$props")), parentComponent.params[0])));
    }
};
//# sourceMappingURL=util.js.map