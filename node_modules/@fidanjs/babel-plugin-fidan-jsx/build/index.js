"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// original: https://github.com/ryansolid/babel-plugin-jsx-dom-expressions/blob/master/src/index.js
const t = require("@babel/types");
const anymatch = require("anymatch");
const plugin_syntax_jsx_1 = require("@babel/plugin-syntax-jsx");
const generate_1 = require("./generate");
const ast_1 = require("./ast");
const util_1 = require("./util");
const generator_1 = require("@babel/generator");
const fileExtentions = [".js", ".jsx", ".ts", ".tsx"];
exports.globalOptions = {
    moduleName: "_r$",
    delegateEvents: true,
    isTest: false,
    babelConfig: (pluginPath) => ({
        plugins: [
            pluginPath
                ? [
                    pluginPath,
                    {
                        moduleName: "_r$",
                        isTest: true,
                        exclude: ["**/*.react*"]
                    }
                ]
                : null,
            "@babel/plugin-syntax-dynamic-import",
            ["@babel/plugin-proposal-decorators", { legacy: true }],
            ["@babel/plugin-proposal-class-properties", { loose: true }],
            "@babel/plugin-syntax-jsx"
        ].filter(p => p != null),
        presets: ["@babel/preset-typescript"]
    }),
    fileExtentions: fileExtentions,
    currentFile: {
        path: ""
    },
    defaultPluginOptions: {
        include: fileExtentions.map(ext => "**/*" + ext)
    },
    openedTags: [],
    isSvg: false
};
let doNotTraverse = false;
const errorReport = (e, path, file) => {
    const nodeCode = generator_1.default(path.node).code;
    console.log("FILE: ", file.filename);
    console.log("PART: ", nodeCode);
    console.error("ERROR: ", e);
    debugger;
};
exports.default = babel => {
    return {
        name: "ast-transform",
        inherits: plugin_syntax_jsx_1.default,
        visitor: {
            JSXElement: (path, { opts }) => {
                if (doNotTraverse)
                    return;
                if ("moduleName" in opts)
                    exports.globalOptions.moduleName = opts.moduleName;
                if ("delegateEvents" in opts)
                    exports.globalOptions.delegateEvents = opts.delegateEvents;
                if (path.node.openingElement)
                    exports.globalOptions.isSvg = util_1.isSvgElementTagName(path.node.openingElement.name.name);
                const result = generate_1.generateHTMLNode(path, path.node, opts);
                if (result.id) {
                    ast_1.createTemplate(path, result);
                    if (!result.exprs.length && result.decl.declarations.length === 1)
                        path.replaceWith(result.decl.declarations[0].init);
                    else {
                        util_1.setComponentPropsToDom(path, result);
                        path.replaceWithMultiple([result.decl].concat(result.exprs, t.expressionStatement(result.id)));
                    }
                }
                else
                    path.replaceWith(result.exprs[0]);
            },
            JSXFragment: (path, { opts }) => {
                try {
                    if ("moduleName" in opts)
                        exports.globalOptions.moduleName = opts.moduleName;
                    if ("delegateEvents" in opts)
                        exports.globalOptions.delegateEvents = opts.delegateEvents;
                    if (path.node.openingElement)
                        exports.globalOptions.isSvg = util_1.isSvgElementTagName(path.node.openingElement.name.name);
                    const result = generate_1.generateHTMLNode(path, path.node, opts);
                    ast_1.createTemplate(path, result, true);
                    if (!result.exprs.length && result.decl.declarations.length === 1)
                        path.replaceWith(result.decl.declarations[0].init);
                    else {
                        util_1.setComponentPropsToDom(path, result);
                        path.replaceWithMultiple([result.decl].concat(result.exprs, t.expressionStatement(result.id)));
                    }
                }
                catch (e) {
                    errorReport(e, path, exports.globalOptions.currentFile.path);
                }
            },
            JSXOpeningElement(path, file) {
                exports.globalOptions.openedTags.push(path.node.name["name"]);
            },
            JSXClosingElement(path, file) {
                exports.globalOptions.openedTags.pop();
            },
            Program: {
                enter(path) {
                    exports.globalOptions.currentFile.path = this.filename;
                    exports.globalOptions.isTest = false;
                    const pluginOptions = Object.assign(exports.globalOptions.defaultPluginOptions, this.opts);
                    if (pluginOptions.moduleName) {
                        exports.globalOptions.moduleName = pluginOptions.moduleName;
                    }
                    if (pluginOptions.isTest) {
                        exports.globalOptions.isTest = true;
                    }
                    doNotTraverse = false;
                    // https://github.com/micromatch/anymatch#usage
                    if ((pluginOptions.include &&
                        anymatch(pluginOptions.include, this.file.opts.filename) ===
                            false) ||
                        (pluginOptions.exclude &&
                            anymatch(pluginOptions.exclude, this.file.opts.filename) === true)) {
                        doNotTraverse = true;
                        return;
                    }
                    if (!exports.globalOptions.isTest) {
                        util_1.insertFidanImport(path.node.body);
                    }
                },
                exit: path => {
                    if (path.scope.data.events) {
                        path.node.body.push(t.expressionStatement(t.callExpression(t.memberExpression(t.identifier(exports.globalOptions.moduleName), t.identifier("delegateEvents")), [
                            t.arrayExpression(Array.from(path.scope.data.events).map(e => t.stringLiteral(e.toString())))
                        ])));
                    }
                }
            }
        }
    };
};
//# sourceMappingURL=index.js.map