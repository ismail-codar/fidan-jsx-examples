"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const t = require("@babel/types");
const Attributes_1 = require("./constants/Attributes");
const _1 = require(".");
const util_1 = require("./util");
function setAttr(elem, name, value) {
    if (name === "style") {
        return t.callExpression(t.memberExpression(t.identifier("Object"), t.identifier("assign")), [t.memberExpression(elem, t.identifier(name)), value]);
    }
    let isAttribute = name.indexOf("-") > -1 || _1.globalOptions.isSvg, attribute = Attributes_1.Attributes[name];
    if (attribute)
        if (attribute.type === "attribute")
            isAttribute = true;
        else
            name = attribute.alias;
    if (isAttribute)
        return t.callExpression(t.memberExpression(elem, t.identifier("setAttribute")), [t.stringLiteral(name), value]);
    return t.assignmentExpression("=", t.memberExpression(elem, t.identifier(name)), value);
}
exports.setAttr = setAttr;
function setAttrExpr(elem, name, value) {
    return t.expressionStatement(t.callExpression(t.memberExpression(t.identifier(_1.globalOptions.moduleName), t.identifier("wrap")), [t.arrowFunctionExpression([], setAttr(elem, name, value))]));
}
exports.setAttrExpr = setAttrExpr;
function computeAttribute(elem, name, value) {
    let isAttribute = name.indexOf("-") > -1 || _1.globalOptions.isSvg, attribute = Attributes_1.Attributes[name];
    if (attribute)
        if (attribute.type === "attribute")
            isAttribute = true;
        else
            name = attribute.alias;
    const node = t.callExpression(t.memberExpression(t.identifier(_1.globalOptions.moduleName), t.identifier("attr")), [
        elem,
        t.stringLiteral(name),
        t.booleanLiteral(isAttribute),
        util_1.canBeReactive(value) ? value.callee : value
    ]);
    return node;
}
exports.computeAttribute = computeAttribute;
function createPlaceholder(path, results, tempPath, i) {
    const exprId = path.scope.generateUidIdentifier("el$");
    results.template += `<!--${exprId.name.slice(4)}-->`;
    results.decl.push(t.variableDeclarator(exprId, t.memberExpression(t.identifier(tempPath), t.identifier(i === 0 ? "firstChild" : "nextSibling"))));
    return exprId;
}
exports.createPlaceholder = createPlaceholder;
function createTemplate(path, results, isFragment) {
    let decl;
    if (results.template.length) {
        const templateId = path.scope.generateUidIdentifier("tmpl$"), program = path.findParent(t => t.isProgram()).node;
        decl = t.variableDeclarator(results.id, t.callExpression(isFragment
            ? t.memberExpression(t.memberExpression(templateId, t.identifier("content")), t.identifier("cloneNode"))
            : t.memberExpression(t.memberExpression(_1.globalOptions.isSvg
                ? t.memberExpression(t.memberExpression(templateId, t.identifier("content")), t.identifier("firstChild"))
                : t.memberExpression(templateId, t.identifier("content")), t.identifier("firstChild")), t.identifier("cloneNode")), [t.booleanLiteral(true)]));
        program.body.unshift(t.variableDeclaration("const", [
            t.variableDeclarator(templateId, t.callExpression(t.memberExpression(t.identifier("document"), t.identifier("createElement")), [t.stringLiteral("template")]))
        ]), t.expressionStatement(t.assignmentExpression("=", t.memberExpression(templateId, t.identifier("innerHTML")), t.stringLiteral(_1.globalOptions.isSvg && !results.template.startsWith("<svg")
            ? `<svg>${results.template}</svg>`
            : results.template))));
    }
    else {
        decl = t.variableDeclarator(results.id, t.callExpression(t.memberExpression(t.identifier("document"), t.identifier("createDocumentFragment")), []));
    }
    results.decl.unshift(decl);
    results.decl = t.variableDeclaration("const", results.decl);
}
exports.createTemplate = createTemplate;
exports.insertOrConditional = (results, innerExpr, exprId) => {
    const methodName = t.isConditionalExpression(innerExpr)
        ? "conditional"
        : "insert";
    results.exprs.push(t.expressionStatement(t.callExpression(t.memberExpression(t.identifier(_1.globalOptions.moduleName), t.identifier(methodName)), [
        results.id,
        t.isConditionalExpression(innerExpr)
            ? t.objectExpression([
                t.objectProperty(t.stringLiteral("test"), t.isCallExpression(innerExpr.test) &&
                    innerExpr.test.arguments.length > 0
                    ? innerExpr.test // compute(..)
                    : t.arrowFunctionExpression([], innerExpr.test)),
                t.objectProperty(t.identifier("consequent"), innerExpr.consequent),
                t.objectProperty(t.identifier("alternate"), innerExpr.alternate)
            ])
            : util_1.canBeReactive(innerExpr)
                ? innerExpr.callee
                : innerExpr,
        t.nullLiteral(),
        exprId
    ])));
};
exports.arrayMapExpression = (results, innerExpr, exprId) => {
    results.exprs.push(t.expressionStatement(t.callExpression(t.memberExpression(t.identifier(_1.globalOptions.moduleName), t.identifier("arrayMap")), [
        results.id,
        innerExpr.callee["object"].callee,
        innerExpr.arguments[0],
        exprId
    ])));
};
//# sourceMappingURL=ast.js.map