import { arrayMap, compute } from '@fidanjs/runtime';

var eventRegistry = new Set();

function lookup(el, name) {
  var h = el[name],
      m = el.model,
      r,
      p;
  if ((h === undefined || h.length > 1 && m === undefined) && (p = el.host || el.parentNode)) { r = lookup(p, name); }
  return [h !== undefined ? h : r && r[0], m || r && r[1]];
}

function eventHandler(e) {
  var node = e.composedPath && e.composedPath()[0] || e.target;
  var ref = lookup(node, ("__" + (e.type)));
  var handler = ref[0];
  var model = ref[1]; // reverse Shadow DOM retargetting

  if (e.target !== node) {
    Object.defineProperty(e, "target", {
      configurable: true,
      value: node
    });
  }

  return handler && handler(e, model);
}

var delegateEvents = function (eventNames) {
  for (var i = 0, l = eventNames.length; i < l; i++) {
    var name = eventNames[i];

    if (!eventRegistry.has(name)) {
      eventRegistry.add(name);
      document.addEventListener(name, eventHandler);
    }
  }
};

var jsxArrayMap = function (arr, renderCallback, renderMode) {
  return function (parentElement) {
    arrayMap(arr, parentElement, undefined, renderCallback, renderMode);
  };
};

var arrayMap$1 = function (parent, arr, renderCallback, marker) {
  arrayMap(arr, parent, marker, renderCallback, "reconcile");
};
var insert = function (parent, accessor, init, marker) {
  if (typeof accessor === "object") {
    parent.insertBefore(accessor, marker);
  } else if (typeof accessor === "function") {
    var node = document.createTextNode("");

    if (accessor.hasOwnProperty("$val")) {
      compute(function () {
        node.data = accessor();

        if (!node.parentNode) {
          parent.insertBefore(node, marker);
        }
      });
    } else {
      node.data = accessor();
      parent.insertBefore(node, marker);
    }
  } else {
    var node$1 = document.createTextNode(accessor);
    parent.insertBefore(node$1, marker);
  }
};
var spread = function (node, accessor) {
  if (typeof accessor === "function") {
    accessor(node);
  } else {
    if (accessor instanceof Node === false) { accessor = document.createTextNode(accessor || ""); }
    node.appendChild(accessor);
  }
};
var attr = function (node, attributeName, setAttr, cmp) {
  if (cmp.hasOwnProperty("$val")) {
    if (setAttr) {
      compute(function () { return node.setAttribute(attributeName, cmp()); }, [cmp]);
    } else {
      compute(function () { return node[attributeName] = cmp(); }, [cmp]);
    }
  } else {
    if (typeof cmp === "function") {
      cmp = cmp(node);
    }

    if (setAttr) {
      node.setAttribute(attributeName, cmp);
    } else {
      node[attributeName] = cmp;
    }
  }
};
var conditional = function (parent, condition, init, marker) {
  var oldElement = null;
  var lastVal = false;
  var conditionCompute = condition.test.hasOwnProperty("$val") ? condition.test : compute(condition.test);
  compute(function () {
    if (oldElement && parent.childElementCount === 0) {
      return;
    }

    var val = !!conditionCompute();

    if (val !== lastVal) {
      if (parent && parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        parent = marker.parentNode;
      }

      var newElement = val ? condition.consequent : condition.alternate;
      if (newElement instanceof Node === false) { newElement = document.createTextNode(newElement || ""); }

      if (oldElement) {
        parent.replaceChild(newElement, oldElement);
      } else {
        parent.insertBefore(newElement, marker);
      }

      oldElement = newElement;
    }

    lastVal = val;
  }, [conditionCompute]);
};

export { arrayMap$1 as arrayMap, insert, spread, attr, conditional, delegateEvents, jsxArrayMap };
//# sourceMappingURL=index.mjs.map
